
#Задачи по теме "Работа со списками"
#
#1) Дан произвольный список. Представьте его в обратном порядке.

lst = [1.2,2,56,12,7,0,12]


for i in reversed(lst):
    print(i)
 


#2) Напишите функцию change(lst), которая принимает список и меняет местами его первый 
#и последний элемент. В исходном списке минимум 2 элемента.
def change(lst):
    lst[0], lst[-1] = lst[-1], lst[0]
    return lst
print("change(lst) : ", change(lst))

#3) Функция to_list() принимает неограниченное количество параметров. 
#Обработайте их так, чтобы на выходе получить список из этих элементов.
def to_list(*args):
    newList = list()
    for i in args:
        newList.append(i)
    return newList
print("newList : ", to_list(1,2,3,4,5,6,7,8))

#4) Николай задумался о поиске "бесполезного" числа на основании списка. 
#Суть оного в следующем: он берет произвольный список чисел, находит самое 
#большое из них, а затем делит его на длину списка. Студент пока не придумал, 
#где может пригодиться подобное значение, но ищет у вас помощи в реализации 
#такой функции useless(s).
def useless(s):
    
    return max(lst) / len(lst)

print("useless : ", useless(lst))

#5) Требуется создать функцию list_sort(lst), которая сортирует список 
#чисел по убыванию их абсолютного значения.

def list_sort(lst):
    return sorted(lst, reverse = True)

print("list_sort : ", list_sort(lst))


#6*) На входе имеем список строк разной длины. Необходимо написать функцию all_eq(lst),
# которая вернет новый список из строк одинаковой длины.
#    Длину итоговой строки определяем исходя из самой большой из них. 
#    Если конкретная строка короче самой длинной, дополнить ее нижними 
#    подчеркиваниями с правого края до требуемого количества символов.

#    Расположение элементов начального списка не менять.

def all_eq(lst):
    max = len(lst)
    for i in lst:
        if len(i) > max:
            max = len(i)
    result = list()
    for i in lst:
        result.append(i.ljust(max, "_"))
    return result

print("all_eq(lst) : ", all_eq(["fdbdzb ","sdgs","sdgsdgs","dv", "fbdfb"]))


print()
#Задачи по теме "Работа с кортежами"
#
#1) Напишите функцию tpl_sort(), которая сортирует кортеж, состоит из целых чисел по возрастанию и возвращает его.
# Если хотя бы один элемент не является целым числом, то функция возвращает исходный кортеж.
def tpl_sort():
    newTpl = tuple((1,5,78,0,45,1.2,1,23,1))
    
    for i in newTpl:
        if not str(i).isdigit():
            return newTpl
    return tuple(sorted(newTpl))

print("tpl_sort : ", tpl_sort())

#2) Функция slicer() на вход принимает кортеж и случайный элемент. 
#Требуется вернуть новый кортеж, начинающийся с первого появления 
#элемента в нем и заканчивающийся вторым его появлением включительно.
# - Если элемента нет вовсе – вернуть пустой кортеж.
# - Если элемент встречается только один раз, то вернуть кортеж, который начинается с него и идет до конца исходного.

def slicer(tpl, elem):
    flag = False
    newTpl = list()
    for i in tpl:
        if i == elem or flag:
            newTpl.append(i)
            if elem == i:
                flag = not flag
    return tuple(newTpl)

print("slicer() : ", slicer((1,2,5,6,3,2,1,4,5,8),2))

#3) Перед студентом стоит задача: на вход функции sieve() поступает список целых чисел. 
#В результате выполнения этой функции будет получен кортеж уникальных элементов списка в обратном порядке.

def sieve(lst):
    return tuple(set(reversed(lst))) #лист преобразовывем во множество, чтобы убрать дубликаты

print("sieve : ", sieve([1,85,1,0,12,4,5,6,5,78,12,4]))


#4) Николай знает, что кортежи являются неизменяемыми, но он с этим не готов соглашаться.
# Ученик решил создать функцию del_from_tuple(), которая будет удалять первое появление 
# определенного элемента из кортежа по значению и возвращать кортеж без оного. 
# Попробуйте повторить шедевр не признающего авторитеты начинающего программиста.
#  К слову, Николай не всегда уверен в наличии элемента в кортеже (в этом случае кортеж вернется функцией в исходном виде).

def del_from_tuple(tpl,elem):
    lst = list(tpl)
    if elem not in lst:
        return tpl
    else: 
        lst.remove(elem)
        return tuple(lst)

print("sel_from_tuple :", del_from_tuple((52,45,1,23,7,4,512,7,512),512))

#5*) Создайте кортеж из 7-ми именованных кортежей учащихся ВУЗов.
# В именованном кортеже будут присутствовать следующие поля: имя студента, 
# возраст, оценка за семестр, город проживания. Функция good_students() 
# будет принимать этот кортеж, вычислять среднюю оценку по всем учащимся 
# и выводить на печать следующее сообщение: "Ученики {список имен студентов через запятую} 
# в этом семестре хорошо учатся!". В список студентов, которые выводятся по результатам 
# работы функции, попадут лишь те, у которых оценка за семестр равна или выше средней по всем учащимся.

students = (
    ("Begimay", 17, 4, "Astana"),
    ("Aldiyar", 17, 4, "Astana"),
    ("Madi", 18, 5, "Astana"),
    ("Varvara", 17, 2, "Astana"),
    ("Boris", 17, 1, "Astana"),
    ("Beka", 18, 5, "Astana"),
    ("Aliya", 17, 4, "Astana")
    )

def good_students(tpl):
    a = 0
    for i in tpl:
        a+=i[2]

    avg = a/len(tpl)
    return f"Ученики {[i[0] for i in tpl if i[2] >= avg]} в этом семестре хорошо учатся!"

print(good_students(students))



print()
#Задачи по теме "Работа с множествами"

#1) На входе функция to_set() получает строку или список чисел. Преобразуйте их в множество. 
#На выходе должно получиться множество и его мощность.

def to_set(sm):
    return set(sm), len(sm)

print("to_set(str) : ", to_set("svdfbfd"))
print("to_set(list) : ", to_set(["svdfbfd","vdfsvd","dfvdv",12,1.0]))

#3) На основании 3 исходных множеств (передаются в качестве аргументов функции diff()) 
#требуется написать функцию, которая будет возвращать либо симметричную разность, либо 
#просто разность (если дополнительный аргумент функции symmetric имеет значение False) 
#приведенных объектов в порядке: 1-ое множество, 2-ое множество, 3-е множество.

def diff(set1, set2, set3, symmetric=True):
    if symmetric:
        return (set1 ^ set2 ^ set3)
    else:
        return (set1 - set2 - set3)


#4) Напишите функцию superset(), которая принимает 2 множества.
#Результат работы функции - вывод в консоль одного из сообщений в зависимости от ситуации:
#1 - "Супермножество не обнаружено"
#2 – "Объект {X} является чистым супермножеством"
#3 – "Множества равны"

def superset(a,b):
    if a == b: 
        return "Множества равны"
    elif b >= a:
        return "Объект {b} является чистым супермножеством"
    elif b <= a:
        return "Объект {a} является чистым супермножеством"
    else:
        return "Супермножество не обнаружено"

print("superset(a,b) : ", superset({1,2,3},{1,2,3,4,5,6}))
print("superset(a,b) : ", superset({1,2,3,4,5,6}, {1,2}))
print("superset(a,b) : ", superset({1,2,3},{1,2,3}))
print("superset(a,b) : ", superset({11,21,13},{1,2,3,4,5,6}))


#5*) Предоставлен список натуральных чисел. 
#Требуется сформировать из них множество. 
#Если какое-либо число повторяется, то преобразовать его в строку по образцу: 
#например, если число 4 повторяется 3 раза, то в множестве будет следующая запись: 
#само число 4, строка 44 (второе повторение, т.е. число дублируется в строке), 
#строка 444 (третье повторение, т.е. строка множится на 3). 
#Реализуйте вывод множества через функцию set_gen().

lst = [1,23,4,5,1,5,23,7,5,6,8]

def set_gen(lst):
    dict = {}
    mySet = [] # я использую список вместо множества из-за того, 
               # множество при добавлении элементов автоматически сортирует его

    for i in lst:
        if i not in dict:
            dict[i] = 1
            mySet.append(i)
        else:
            dict[i]+=1
            mySet.append(str(i)*dict[i])

    return set(mySet) 

print("set_gen(lst) : ", set_gen(lst) )

